package gen_route

import (
	"bytes"
	"fmt"
	"gen/internal/helper"
	"go/ast"
	"go/parser"
	"go/token"
	"golang.org/x/tools/imports"
	"html/template"
	"io/ioutil"
	"reflect"
	"regexp"
	"strings"
)

const matchCommentRequestMap = "@RequestMap\\(([a-z]*=\"[\\S\\s]*\").*\\)"

type methodRef struct {
	Name       string
	MethodType string
	Path       string
}

type controllerRef struct {
	Name        string
	RequestPath string
	PackageName string
	Methods     []methodRef
}

func templateFile(controllers []controllerRef, filePackage string) []byte {
	helperFuncs := template.FuncMap{
		"makeCtrVarName": func(str string) string {
			str = strings.ToLower(string(str[0])) + str[1:]
			return str
		},
		"firstLower":       FirstLower,
		"makeGroupVarName": MakeGroupVarName,
	}
	temp := `
//Code generated by Gen. DO NOT EDIT.
//Code generated by Gen. DO NOT EDIT.
//Code generated by Gen. DO NOT EDIT.

package {{.Package}}
import (
	
	"github.com/gin-gonic/gin"
)
func AmountRoute(router *gin.Engine ) *gin.Engine {
	{{range $i, $v := .Controllers}}
	var {{$v.Name | makeCtrVarName}} = Init{{$v.Name}}()
	{{$v.RequestPath | makeGroupVarName}}:=router.Group("{{$v.RequestPath}}")
	{ 
		{{range $e, $m := $v.Methods}}
		{{$v.RequestPath | makeGroupVarName}}.{{$m.MethodType}}("{{$m.Path}}",{{$v.Name | makeCtrVarName}}.{{$m.Name}})
		{{end}}	
	}
	{{end}}

	return router
}`
	out := bytes.NewBufferString("")
	// Parse the template and pass it the helper functions
	t := template.Must(template.New("go_route_gen.tmpl").Funcs(helperFuncs).Parse(temp))
	// Execute the template and pass it the metadata we collected before
	t.Execute(out, map[string]interface{}{"Controllers": controllers,"Package": filePackage})
	return out.Bytes()
}

func FirstLower(str string) string {
	return strings.ToLower(string(str[0])) + str[1:]
}
func MakeGroupVarName(str string) string {
	str = strings.Trim(str, "/")
	str = strings.ToLower(string(str[0])) + str[1:] + "Group"

	return str
}


func Gen(filePath string, routerFile string) {
	var files []string
	files, err :=  helper.GetAllFiles(filePath)

	ctrColl := make([]controllerRef, 0)
	for _, v := range files {
		controllers := parse(v)
		for _, v := range controllers {
			if len(v.Methods) < 1 {
				continue
			}
			ctrColl = append(ctrColl, v)
		}
	}
	s:="gen_build"
	res := templateFile(ctrColl,s)
	formattedCode, err := imports.Process(routerFile, res, &imports.Options{Comments: true})
	if err != nil {
		fmt.Printf("cannot format source code, might be an error in template: %s\n", err)
	}
	ioutil.WriteFile(routerFile, formattedCode, 0777)
}

func parse(file string) []controllerRef {
	controllers := make([]controllerRef, 0)

	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	//ast.Print(fset, f)
	//return controllers
	/***
	解析Controller 属性
	*/

	for _, v := range f.Decls {
		fn, ok := v.(*ast.GenDecl)
		if !ok {
			continue
		}
		if fn.Doc == nil {
			continue
		}
		fnDoc := fn.Doc.List
		structComment := make([]string, 0)
		controllerRefItem := controllerRef{}
		for _, v := range fnDoc {
			if len(structComment) == 2 {
				break
			}
			if v.Text == "//@Controller" {
				structComment = append(structComment, v.Text)
				continue
			}
			l, _ := regexp.MatchString(matchCommentRequestMap, v.Text)
			if l {
				controllerRefItem.RequestPath = parseRequestMap(v.Text).Path.Value
				structComment = append(structComment, v.Text)
				continue
			}
		}
		if len(structComment) == 2 {
			controllerRefItem.Name = fn.Specs[0].(*ast.TypeSpec).Name.Obj.Name
			controllerRefItem.PackageName = f.Name.Name
			if ('A' <= controllerRefItem.Name[0] && controllerRefItem.Name[0] <= 'Z') == false {
				continue
			}
			controllers = append(controllers, controllerRefItem)
		}

	}
	for _, v := range f.Decls {
		fn, ok := v.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if fn.Recv != nil {
			//地址接收和非地址接收不通
			//func (rs RoleService)FindName() 和func (rs *RoleService)FindName()
			ident,ok:=fn.Recv.List[0].Type.(*ast.StarExpr)
			var structName =""
			if ok {
				structName =ident.X.(*ast.Ident).Name
			}else {
				structName = fn.Recv.List[0].Type.(*ast.Ident).Name
			}


			methodComment := fn.Doc.Text()
			for k, c := range controllers {
				if structName == c.Name {
					u := fn.Name.Name[0]
					if ('A' <= u && u <= 'Z') == false {
						continue
					}
					l, _ := regexp.MatchString(matchCommentRequestMap, methodComment)
					if !l {
						continue
					}
					methodRef := methodRef{}
					r := parseRequestMap(methodComment)
					methodRef.Name = fn.Name.Name
					if r.Path.Value != "" {
						methodRef.Path = r.Path.Value
					} else {
						methodRef.Path = fn.Name.Name
					}
					methodRef.MethodType = r.Method.Value

					controllers[k].Methods = append(c.Methods, methodRef)
				}
			}
		}
	}

	return controllers
}

type requestMapValue struct {
	Path   requestMapItem
	Method requestMapItem
	Group  requestMapItem
}
type requestMapItem struct {
	Key   string
	Value string
}

func parseRequestMap(text string) requestMapValue {
	//eg @RequestMap("method"="post" ...) max haven ten key=>value
	res := requestMapValue{}
	t := reflect.TypeOf(res)
	st := regexp.MustCompile("([a-z]*)=([^,)]*)").FindAllString(text, t.NumField())
	for _, v := range st {
		item := requestMapItem{}
		value := strings.Split(v, "=")
		item.Key = value[0]
		item.Value = strings.Trim(value[1], "\"")
		if value[0] == "method" {
			res.Method = item
			res.Method.Value = strings.ToUpper(item.Value)
		}
		if value[0] == "path" {
			res.Path = item
		}
		if value[0] == "group" {
			res.Group = item
		}
	}

	return res
}
